Fix train times loading issue
train-times



Conversation
Diff
Logs

index.html
index.html
+40
-6

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Train Times">
    
    <!-- Cache Control - Prevent Caching -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- App Version - Update this with each deployment to force cache refresh -->
    <meta name="app-version" content="2.0.3">
    <meta name="app-version" content="2.0.5">
    
    <title>Train Times - Palmers Green</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        @media (display-mode: standalone) {
            body { padding-top: env(safe-area-inset-top); }
        }
        
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(236, 72, 153, 0.3); }
            50% { box-shadow: 0 0 30px rgba(236, 72, 153, 0.5); }
        }
        
@@ -403,50 +403,87 @@
        function getTrackedDepartureTime(service) {
            if (!service) return null;

            const scheduled = service.std || service.sta;
            const expected = service.etd || service.eta;
            const status = getServiceStatus(service);

            if (status === 'delayed') {
                return parseDepartureTime(expected) || parseDepartureTime(scheduled);
            }

            return parseDepartureTime(scheduled);
        }

        function sendTrackedNotification(title, body) {
            if (!('Notification' in window) || Notification.permission !== 'granted') {
                return;
            }

            new Notification(title, {
                body,
                icon: 'ðŸš‚'
            });
        }

        async function fetchJsonWithFallback(url) {
            const candidates = [
                inputUrl => inputUrl,
                inputUrl => `https://api.allorigins.win/raw?url=${encodeURIComponent(inputUrl)}`,
                inputUrl => `https://thingproxy.freeboard.io/fetch/${inputUrl}`,
                inputUrl => `https://r.jina.ai/http://${inputUrl.replace(/^https?:\/\//, '')}`
            ];

            let lastError = null;

            for (const buildUrl of candidates) {
                const attemptUrl = buildUrl(url);
                try {
                    const response = await fetch(attemptUrl, { cache: 'no-store' });
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }

                    const contentType = response.headers.get('content-type') || '';
                    if (contentType.includes('application/json')) {
                        return await response.json();
                    }

                    const text = await response.text();
                    try {
                        return JSON.parse(text);
                    } catch (parseError) {
                        throw new Error('Non-JSON response');
                    }
                } catch (error) {
                    lastError = error;
                }
            }

            throw lastError || new Error('All data sources failed.');
        }

        async function fetchTrains() {
            const refreshIcon = document.getElementById('refreshIcon');
            const trainList = document.getElementById('trainList');
            const statusMessage = document.getElementById('statusMessage');
            const routeInfo = document.getElementById('routeInfo');
            const walkingTimeEl = document.getElementById('walkingTime');
            
            refreshIcon.classList.add('animate-spin');
            statusMessage.classList.add('hidden');
            walkingTimeEl.classList.add('hidden');
            walkingTimeEl.innerHTML = '';

            try {
                let fromStation, toStation;
                let url;
                
                if (currentMode === 'out') {
                    fromStation = PALMERS_GREEN.code;
                    toStation = MOORGATE.code;
                    routeInfo.textContent = `${PALMERS_GREEN.name} â†’ ${MOORGATE.name}`;
                    url = `https://huxley2.azurewebsites.net/departures/${fromStation}/to/${toStation}/20`;
                } else {
                    const selectEl = document.getElementById('homeStationSelect');
                    const selectedCode = selectEl.value || GREAT_NORTHERN_STATIONS[0].code;
                    const station = GREAT_NORTHERN_STATIONS.find(s => s.code === selectedCode) || GREAT_NORTHERN_STATIONS[0];
@@ -456,54 +493,51 @@
                    url = `https://huxley2.azurewebsites.net/departures/${fromStation}/20?expand=true`;

                    const mapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${station.lat},${station.lon}&travelmode=walking`;

                    try {
                        userLocation = await getUserLocation();
                        const walkingMins = await getWalkingTime(
                            userLocation.lat, userLocation.lon,
                            station.lat, station.lon
                        );

                        if (walkingMins !== null) {
                            walkingTimeEl.innerHTML = `ðŸš¶ ${walkingMins} min walk to ${station.name} Â· <a href="${mapsUrl}" target="_blank" rel="noopener" class="underline text-pink-300 hover:text-pink-200 transition-colors">Open in Google Maps</a>`;
                        } else {
                            walkingTimeEl.innerHTML = `<a href="${mapsUrl}" target="_blank" rel="noopener" class="underline text-pink-300 hover:text-pink-200 transition-colors">Walking directions to ${station.name} in Google Maps</a>`;
                        }

                        walkingTimeEl.classList.remove('hidden');
                    } catch (locError) {
                        walkingTimeEl.innerHTML = `<a href="${mapsUrl}" target="_blank" rel="noopener" class="underline text-pink-300 hover:text-pink-200 transition-colors">Walking directions to ${station.name} in Google Maps</a>`;
                        walkingTimeEl.classList.remove('hidden');
                        console.warn('Could not get user location for walking time:', locError);
                    }
                }

                const response = await fetch(url);
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const data = await response.json();
                const data = await fetchJsonWithFallback(url);
                let services = data.trainServices || [];

                if (currentMode === 'home') {
                    services = services.filter(service => {
                        const groups = service.subsequentCallingPoints || [];
                        return groups.some(group =>
                            group.callingPoint &&
                            group.callingPoint.some(cp => cp.crs === PALMERS_GREEN.code)
                        );
                    });
                }

                lastTrainServices = services;

                if (currentMode === 'out' && trackedServiceID && services.length > 0) {
                    const trackedService = services.find(s => (s.serviceID || s.serviceId) === trackedServiceID);
                    if (trackedService) {
                        const newStatus = getServiceStatus(trackedService);
                        const scheduled = trackedService.std || trackedService.sta;
                        const expected = trackedService.etd || trackedService.eta;

                        if (newStatus === 'delayed') {
                            if (trackedServiceStatus !== 'delayed') {
                                sendTrackedNotification(
                                    'Tracked Train Delayed',
@@ -712,51 +746,51 @@
            if (e.target.checked) {
                autoRefreshInterval = setInterval(fetchTrains, 60000);
            } else {
                clearInterval(autoRefreshInterval);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            populateHomeStations();
            const homeSelect = document.getElementById('homeStationSelect');
            if (homeSelect) {
                homeSelect.addEventListener('change', () => {
                    if (currentMode === 'home') {
                        fetchTrains();
                    }
                });
            }
        });

        if ('Notification' in window && Notification.permission === 'granted') {
            document.getElementById('notifyBtn').style.display = 'none';
        }

        // App Version Management - Force updates on iOS home screen
        // IMPORTANT: Update APP_VERSION in both the meta tag and here when deploying new changes
        const APP_VERSION = '2.0.3';
        const APP_VERSION = '2.0.5';
        const VERSION_KEY = 'train-times-version';
        const LAST_CHECK_KEY = 'train-times-last-check';

        function checkForUpdates() {
            // Check if we're in standalone mode (iOS home screen app)
            const isStandalone = window.navigator.standalone || 
                                 window.matchMedia('(display-mode: standalone)').matches;
            
            if (!isStandalone) {
                // For regular browser, check every 5 minutes
                const lastCheck = localStorage.getItem(LAST_CHECK_KEY);
                const now = Date.now();
                if (lastCheck && (now - parseInt(lastCheck)) < 300000) {
                    return; // Checked recently, skip
                }
            }

            // Fetch the current page with cache-busting to check version
            const url = `${window.location.origin}${window.location.pathname}?v=${Date.now()}&_nocache=1`;
            fetch(url, {
                method: 'GET',
                cache: 'no-store',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache'
