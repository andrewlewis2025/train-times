
import React, { useState, useEffect, useCallback } from 'react';
import { Header } from './components/Header';
import { RouteInfo } from './components/RouteInfo';
import { StatusMessage } from './components/StatusMessage';
import { TrainList } from './components/TrainList';
import { findNearestStation } from './utils/location';
import { PALMERS_GREEN, MOORGATE } from './constants';
import type { TrainService, Station, Status } from './types';

const App: React.FC = () => {
    const [mode, setMode] = useState<'out' | 'home'>('out');
    const [trains, setTrains] = useState<TrainService[]>([]);
    const [status, setStatus] = useState<Status | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [fromStation, setFromStation] = useState<Station>(PALMERS_GREEN);
    const [toStation, setToStation] = useState<Station>(MOORGATE);
    const [walkingInfo, setWalkingInfo] = useState<{ minutes: number; stationName: string; mapsUrl: string } | null>(null);
    const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
    const [refreshTrigger, setRefreshTrigger] = useState(0);

    const handleRefresh = useCallback(() => {
        setRefreshTrigger(prev => prev + 1);
    }, []);

    const fetchTrains = useCallback(async () => {
        setIsLoading(true);
        setStatus({ type: 'info', message: 'Fetching train times...' });
        setTrains([]);
        setWalkingInfo(null);

        let currentFromStation: Station = PALMERS_GREEN;
        let currentToStation: Station = MOORGATE;
        let filterForPalmersGreen = false;

        try {
            if (mode === 'home') {
                setStatus({ type: 'info', message: 'Getting your location...' });
                const position = await new Promise<GeolocationPosition>((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 15000, // Increased timeout
                        maximumAge: 60000,
                    });
                });

                const { latitude, longitude } = position.coords;
                const { station: nearestStation, distance } = findNearestStation(latitude, longitude);

                if (distance > 10) { // 10km threshold
                    setStatus({ type: 'warning', message: `You're over 10km from the nearest station. Showing results from ${nearestStation.name}.` });
                } else {
                     setStatus({ type: 'info', message: `Found nearest station: ${nearestStation.name}. Fetching trains...` });
                }
                
                currentFromStation = nearestStation;
                currentToStation = PALMERS_GREEN;
                setFromStation(nearestStation);
                setToStation(PALMERS_GREEN);
                filterForPalmersGreen = true;
                
                const walkingMinutes = Math.round((distance * 1000) / 80); // ~80m/min
                const mapsUrl = `https://www.google.com/maps/dir/?api=1&origin=Current+Location&destination=${nearestStation.lat},${nearestStation.lon}&travelmode=walking`;
                setWalkingInfo({ minutes: walkingMinutes, stationName: nearestStation.name, mapsUrl });

            } else {
                setFromStation(PALMERS_GREEN);
                setToStation(MOORGATE);
                currentFromStation = PALMERS_GREEN;
                currentToStation = MOORGATE;
            }

            const url = `https://huxley2.azurewebsites.net/departures/${currentFromStation.code}/20`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`API error: ${response.statusText}`);
            const data = await response.json();

            if (!data.trainServices || data.trainServices.length === 0) {
                setTrains([]);
                setStatus({ type: 'warning', message: `No trains found from ${currentFromStation.name}.` });
                return;
            }

            let services: TrainService[] = data.trainServices;
            if (filterForPalmersGreen) {
                services = services.filter(service => {
                    const isDestination = service.destination?.[0]?.crs === PALMERS_GREEN.code;
                    const isSubsequentStop = service.subsequentCallingPoints?.[0]?.callingPoint.some(
                        point => point.crs === PALMERS_GREEN.code
                    );
                    return isDestination || isSubsequentStop;
                });
            } else {
                 services = services.filter(service => 
                    service.destination?.[0]?.crs === MOORGATE.code
                );
            }
            
            setTrains(services);
            setLastUpdated(new Date());
            if (services.length > 0) {
                setStatus({ type: 'success', message: 'Live times from National Rail.' });
            } else {
                setStatus({ type: 'warning', message: `No direct trains to ${currentToStation.name} from ${currentFromStation.name} at the moment.` });
            }

        } catch (error: any) {
            console.error(error);
            let errorMessage = `Failed to fetch data: ${error.message}`;

            if (typeof GeolocationPositionError !== 'undefined' && error instanceof GeolocationPositionError) {
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage = "Location permission denied. Please enable it in your browser settings to use 'Home' mode.";
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage = "Location information is currently unavailable. Please check your network or try again.";
                        break;
                    case error.TIMEOUT:
                        errorMessage = "Getting your location took too long. Please try refreshing.";
                        break;
                    default:
                        errorMessage = "An unknown error occurred while getting your location.";
                        break;
                }
            } else if (error.message.includes('API error')) {
                 errorMessage = `Could not connect to National Rail services. Please check your internet connection and try again.`;
            }
            
            setStatus({ type: 'error', message: errorMessage });
        } finally {
            setIsLoading(false);
        }
    }, [mode]);

    useEffect(() => {
        fetchTrains();
    }, [fetchTrains, refreshTrigger]);

    useEffect(() => {
        const interval = setInterval(() => {
            handleRefresh();
        }, 60000); // Auto-refresh every 60 seconds
        return () => clearInterval(interval);
    }, [handleRefresh]);

    return (
        <div className="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen font-sans">
            <div className="max-w-2xl mx-auto p-4">
                <Header 
                    mode={mode} 
                    setMode={setMode} 
                    onRefresh={handleRefresh} 
                    isLoading={isLoading} 
                />
                <main>
                    <RouteInfo 
                        fromStation={fromStation}
                        toStation={toStation}
                        walkingInfo={walkingInfo}
                        lastUpdated={lastUpdated}
                    />
                    {status && <StatusMessage status={status} />}
                    <TrainList trains={trains} isLoading={isLoading} />
                </main>
            </div>
        </div>
    );
};

export default App;
